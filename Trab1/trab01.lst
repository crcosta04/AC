P16 assembler v1.4.0 (Mar  6 2023)	d:\ISEL\2223\LEIC\s2\AC\Trab1\trab01.lst	Wed Mar 22 19:52:41 2023

Sections
Index   Name            Address   Size
0       .startup        0000      0020 32
1       .text           0020      0106 262
2       .data           0126      0015 21
3       .bss            013C      0002 2
4       .stack          013E      0040 64

Symbols
Name                    Type      Value       Section
_start                  LABEL     0004 4      .startup
ACHAR                   ABSOLUTE  0041 65     .startup
char2nat                LABEL     007A 122    .text
char2nat_addr           LABEL     0074 116    .text
char2nat_end            LABEL     00B4 180    .text
EIGHT                   ABSOLUTE  0008 8      .startup
error                   LABEL     013C 316    .bss
error_addr              LABEL     0078 120    .text
error_addr2             LABEL     0124 292    .text
error_shift             LABEL     005A 90     .text
FCHAR                   ABSOLUTE  0046 70     .startup
for_else                LABEL     00F2 242    .text
for_loop                LABEL     00C8 200    .text
FOUR                    ABSOLUTE  0004 4      .startup
line#35                 LABEL     0002 2      .startup
line#49                 LABEL     001A 26     .startup
main                    LABEL     0020 32     .text
main_addr               LABEL     001E 30     .startup
multiply                LABEL     0112 274    .text
NAN                     ABSOLUTE  FFFF 65535  .startup
NINECHAR                ABSOLUTE  0039 57     .startup
number_nan              LABEL     00A8 168    .text
ONE                     ABSOLUTE  0001 1      .startup
radix_if1               LABEL     00A2 162    .text
radix_if2               LABEL     00AE 174    .text
shift                   LABEL     013D 317    .bss
shift_addr              LABEL     0072 114    .text
SIXTEEN                 ABSOLUTE  0010 16     .startup
STACK_SIZE              ABSOLUTE  0040 64     .startup
str2nat                 LABEL     00B8 184    .text
str2nat_addr            LABEL     0076 118    .text
str2nat_end             LABEL     0106 262    .text
symbol_else_if          LABEL     0090 144    .text
tos                     LABEL     017E 382    .stack
tos_addr                LABEL     001C 28     .startup
tst_results             LABEL     0126 294    .data
tst_results_addr        LABEL     0070 112    .text
tst_str0                LABEL     012C 300    .data
tst_str0_addr           LABEL     006A 106    .text
tst_str1                LABEL     0132 306    .data
tst_str1_addr           LABEL     006C 108    .text
tst_str2                LABEL     0136 310    .data
tst_str2_addr           LABEL     006E 110    .text
TWO                     ABSOLUTE  0002 2      .startup
while                   LABEL     0114 276    .text
while_end               LABEL     0120 288    .text
ZERO                    ABSOLUTE  0000 0      .startup
ZEROCHAR                ABSOLUTE  0030 48     .startup

Code listing
   1           	; r0 = multiplicando
   2           	; r1 = multiplicador
   3           	
   4           	;1) a) Esta implementação ocupa 8 bytes de memória, devido ao uso de 4 registos(R0..R3), sendo cada um de 2 bytes tendo em conta as caracteristicas do processor P16.
   5           	;b) Enquanto grupo não concordamos com esta afirmação.
   6           	;Como sabemos os registos em rotinas encontram-se divididos em 3 classes,
   7           	;achamos que não seria preferivel a utilização do R4, pois ao contrário do R2,
   8           	 ;este registo tem necessidade de armazenar o seu valor, 
   9           	 ;tendo em conta o propósito da rotina multiply não faria sentido 
  10           	 ;guardar o valor sendo que o que nos importa é o valor final.
  11           	
  12           	;2) a) O valor da constante NAN é FFFF=65535, porque em hexadecimal cada valor 
  13           	;pode ser compreendido entre 0 e 15, onde 15=F. Neste caso o valor é positivo
  14           	;por ser do tipo uint16_t, ou seja, um intiero sem sinal de 16 bits.
  15           	
  16           	;b) .equ NAN, FFFF ocupa 16 bits, ou seja, 1 registo.
  17           	
  18           	;2 c)
  19           	
  20          	.equ NAN, 0xFFFF
  21          	.equ ZEROCHAR, '0'
  22          	.equ NINECHAR, '9'
  23          	.equ ACHAR, 'A'
  24          	.equ FCHAR, 'F'
  25          	.equ SIXTEEN, 16
  26          	.equ STACK_SIZE, 64
  27          	.equ ZERO, 0
  28          	.equ ONE, 1
  29          	.equ TWO, 2
  30          	.equ FOUR, 4
  31          	.equ EIGHT, 8
  32           	
  33           	.section .startup
  34 0000 01 58	    b _start
  35 0002 FF 5B	    b .
  36           	
  37           	_start:
  38 0004 BD 0C	    ldr sp, tos_addr ; por no sp o address do top of
  39 0006 01 60	    mov r1, # ZERO
  40 0008 72 0F	    ldr r2, error_addr
  41 000A 21 38	    strb r1, [r2, r0]
  42 000C 11 60	    mov r1, # ONE
  43 000E 12 0F	    ldr r2, shift_addr
  44 0010 21 38	    strb r1, [r2, r0]
  45 0012 80 B7	    mov r0, pc
  46 0014 0E A2	    add lr, r0, #4
  47 0016 3F 0C	    ldr pc, main_addr
  48 0018 F2 0E	    ldr r2, error_addr
  49 001A FF 5B	    b .
  50           	
  51           	tos_addr:
  52 001C 7E 01	    .word tos
  53           	
  54           	main_addr:
  55 001E 20 00	    .word main
  56           	
  57           	.text
  58           	
  59           	main:
  60 0020 0E 24	    push lr
  61 0022 30 0E	    ldr r0, tst_str0_addr
  62 0024 04 00	    ldr r4, [r0, # ZERO]
  63 0026 21 60	    mov r1, # TWO
  64 0028 47 5C	    bl str2nat
  65 002A 00 BA	    cmp r0, r4
  66 002C 86 B7	    mov r6, pc
  67 002E 65 A4	    add r5, r6, # EIGHT
  68 0030 05 24	    push r5
  69 0032 13 40	    beq error_shift
  70 0034 B0 0D	    ldr r0, tst_str1_addr
  71 0036 84 00	    ldr r4, [r0, # TWO]
  72 0038 81 60	    mov r1, # EIGHT
  73 003A 3E 5C	    bl str2nat
  74 003C 00 BA	    cmp r0, r4
  75 003E 86 B7	    mov r6, pc
  76 0040 65 A4	    add r5, r6, # EIGHT
  77 0042 05 24	    push r5
  78 0044 0A 40	    beq error_shift
  79 0046 30 0D	    ldr r0, tst_str2_addr
  80 0048 04 01	    ldr r4, [r0, # FOUR]
  81 004A 01 61	    mov r1, # SIXTEEN
  82 004C 35 5C	    bl str2nat
  83 004E 00 BA	    cmp r0, r4
  84 0050 86 B7	    mov r6, pc
  85 0052 65 A4	    add r5, r6, # EIGHT
  86 0054 05 24	    push r5
  87 0056 01 40	    beq error_shift
  88 0058 0F 04	    pop pc
  89           	
  90           	error_shift:
  91 005A 03 60	    mov r3, # ZERO
  92 005C D0 0C	    ldr r0, error_addr
  93 005E 81 C8	    orr r1, r0, r1
  94 0060 81 39	    strb r1, [r0, r3]
  95 0062 70 0C	    ldr r0, shift_addr
  96 0064 91 E0	    lsl r1, r1, # ONE
  97 0066 81 39	    strb r1, [r0, r3]
  98 0068 0F 04	    pop pc
  99           	
 100           	tst_str0_addr:
 101 006A 2C 01	    .word tst_str0
 102           	
 103           	tst_str1_addr:
 104 006C 32 01	    .word tst_str1
 105           	
 106           	tst_str2_addr:
 107 006E 36 01	    .word tst_str2
 108           	
 109           	tst_results_addr:
 110 0070 26 01	    .word tst_results
 111           	
 112           	shift_addr:
 113 0072 3D 01	    .word shift
 114           	
 115           	char2nat_addr:
 116 0074 7A 00	    .word char2nat
 117           	
 118           	str2nat_addr:
 119 0076 B8 00	    .word str2nat
 120           	
 121           	error_addr:
 122 0078 3C 01	    .word error
 123           	
 124           	;r0 = symbol, r1 = radix, r2 = number
 125           	;r3 temporary values
 126           	
 127           	char2nat:
 128 007A F2 6F	    mov r2, # NAN & 0xFF; number = NAN
 129 007C F2 7F	    movt r2, # NAN & 0xFF
 130 007E 03 63	    mov r3, # ZEROCHAR
 131 0080 80 B9	    cmp r0, r3 
 132 0082 06 48	    blo symbol_else_if ; if(symbol < '0') -> symbol_else_if
 133 0084 93 63	    mov r3, # NINECHAR
 134 0086 30 B8	    cmp r3, r0
 135 0088 03 48	    blo symbol_else_if ; if(symbol > '9') -> symbol_else_if
 136 008A 03 63	    mov r3, # ZEROCHAR
 137 008C 82 89	    sub r2, r0, r3 ; number = symbol - '0'
 138 008E 09 58	    b radix_if1
 139           	
 140           	symbol_else_if:
 141 0090 13 64	    mov r3, # ACHAR
 142 0092 80 B9	    cmp r0, r3
 143 0094 06 48	    blo radix_if1    ; if(symbol < 'A') -> radix_if
 144 0096 63 64	    mov r3, # FCHAR
 145 0098 30 B8	    cmp r3, r0
 146 009A 03 48	    blo radix_if1    ; if( symbol > 'F') -> radix_if
 147 009C 13 64	    mov r3, # ACHAR
 148 009E 82 89	    sub r2, r0, r3 ; number = symbol - 'A'
 149 00A0 22 A5	    add r2, r2, #10 ; number = number + 10
 150           	
 151           	radix_if1:
 152 00A2 03 61	    mov r3, # SIXTEEN
 153 00A4 B0 B8	    cmp r3, r1
 154 00A6 03 4C	    bhs radix_if2 ; if(radix <= 16) -> char2nat_end    
 155           	
 156           	number_nan:
 157 00A8 F2 6F	    mov r2, # NAN & 0xFF
 158 00AA F2 7F	    movt r2, # NAN & 0xFF
 159 00AC 03 58	    b char2nat_end
 160           	
 161           	radix_if2:
 162 00AE A0 B8	    cmp r2, r1
 163 00B0 01 48	    blo char2nat_end ; if(number < radix) -> char2nat_end
 164 00B2 FA 5B	    b number_nan
 165           	
 166           	char2nat_end:
 167 00B4 00 B1	    mov r0, r2
 168 00B6 0F B7	    mov pc, lr
 169           	
 170           	;3)
 171           	
 172           	;r0 = &numeral[] , r1 = radix , r2 = number, r3 = error
 173           	;r4 = idx , r5 = tmp , r6/r7 temporario
 174           	
 175           	str2nat:
 176 00B8 04 24	    push r4 ; guardar os valores de r4, r5, r6 e r7 para nao serem perdidos
 177 00BA 05 24	    push r5
 178 00BC 06 24	    push r6
 179 00BE 07 24	    push r7
 180 00C0 02 60	    mov r2, # ZERO & 0xFF; number = 0
 181 00C2 02 70	    movt r2, # ZERO & 0xFF
 182 00C4 F3 0E	    ldr r3, error_addr2; error = 0
 183 00C6 04 60	    mov r4, # ZERO ; idx = 0
 184           	
 185           	for_loop:
 186 00C8 06 60	    mov r6, # ZERO
 187 00CA 30 BB	    cmp r3, r6
 188 00CC 1C 40	    beq str2nat_end ; if( error != 0 ) -> str2nat_end
 189 00CE 06 60	    mov r6, # '\0'
 190 00D0 07 12	    ldr r7, [r0,r4]
 191 00D2 70 BB	    cmp r7, r6
 192 00D4 18 44	    bne str2nat_end ; if( numeral[idx] == '\0' ) -> str2nat_end
 193 00D6 07 B0	    mov r7, r0
 194 00D8 D0 5F	    bl char2nat
 195 00DA 05 B0	    mov r5, r0 ; tmp = char2nat(numeral[idx], radix)
 196 00DC 80 B3	    mov r0, r7
 197 00DE F6 6F	    mov r6, # NAN & 0xFF ; r6 = NAN
 198 00E0 F6 7F	    movt r6, # NAN & 0xFF
 199 00E2 50 BB	    cmp r5, r6 
 200 00E4 06 44	    bne for_else
 201 00E6 F2 6F	    mov r2, # NAN & 0xFF
 202 00E8 F2 7F	    movt r2, # NAN & 0xFF
 203 00EA 14 60	    mov r4, # ONE
 204 00EC 07 60	    mov r7, # ZERO
 205 00EE B4 33	    str r4, [r3, r7]
 206 00F0 EB 5B	    b for_loop
 207           	
 208           	for_else:
 209 00F2 06 B0	    mov r6, r0
 210 00F4 02 24	    push r2
 211 00F6 03 24	    push r3
 212 00F8 0C 5C	    bl multiply
 213 00FA 03 04	    pop r3
 214 00FC 02 04	    pop r2
 215 00FE 07 B0	    mov r7, r0
 216 0100 00 B3	    mov r0, r6
 217 0102 F2 82	    add r2, r7, r5
 218 0104 E1 5B	    b for_loop
 219           	
 220           	str2nat_end:
 221 0106 07 04	    pop r7
 222 0108 06 04	    pop r6
 223 010A 05 04	    pop r5
 224 010C 04 04	    pop r4
 225 010E 00 B1	    mov r0, r2
 226 0110 0F B7	    mov pc, lr
 227           	
 228           	multiply: 
 229 0112 02 60	    mov r2, #0
 230           	
 231           	while:
 232 0114 03 60	    mov r3, #0
 233 0116 B0 B8	    cmp r3, r1
 234 0118 03 4C	    bhs while_end
 235 011A 22 80	    add r2, r2, r0
 236 011C 91 A8	    sub r1, r1, #1
 237 011E FA 5B	    b while
 238           	
 239           	while_end:
 240 0120 00 B1	    mov r0, r2
 241 0122 0F B7	    mov pc, lr
 242           	
 243           	error_addr2:
 244 0124 3C 01	    .word error
 245           	
 246           	; 4)
 247           	
 248           	.data
 249           	
 250           	tst_results:
 251          	    .word 11, 457, 39439
 251 0126 0B 00 C9 01 0F 9A
 252           	
 253           	tst_str0:
 254          	    .asciz "01011"
 254 012C 30 31 30 31 31 00
 255          	    .align
 256           	
 257           	tst_str1:
 258          	    .asciz "709"
 258 0132 37 30 39 00
 259          	    .align
 260           	    
 261           	tst_str2:
 262          	    .asciz "9A0F"
 262 0136 39 41 30 46 00
 263           	
 264           	.section .bss
 265           	
 266           	error:
 267 013C 00   	    .space 1
 268           	
 269           	shift:
 270 013D 00   	    .space 1
 271           	
 272           	.section .stack
 273 013E 00   	.space STACK_SIZE
 273 .... ..
 273 017D 00
 274           	tos:
 275           	; 5)
