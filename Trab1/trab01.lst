P16 assembler v1.4.0 (Mar  6 2023)	d:\ISEL\2223\LEIC\s2\AC\Trab1\trab01.lst	Mon Mar 20 17:46:14 2023

Sections
Index   Name            Address   Size
0       .text           0000      00A6 166

Symbols
Name                    Type      Value       Section
ACHAR                   ABSOLUTE  0041 65     .text
char2nat                LABEL     0000 0      .text
char2nat_end            LABEL     003A 58     .text
FCHAR                   ABSOLUTE  0046 70     .text
for_else                LABEL     0074 116    .text
for_loop                LABEL     004E 78     .text
multiply                LABEL     0094 148    .text
NAN                     ABSOLUTE  FFFF 65535  .text
NINECHAR                ABSOLUTE  0039 57     .text
number_nan              LABEL     002E 46     .text
ONE                     ABSOLUTE  0001 1      .text
radix_if1               LABEL     0028 40     .text
radix_if2               LABEL     0034 52     .text
SIXTEEN                 ABSOLUTE  0010 16     .text
str2nat                 LABEL     003E 62     .text
str2nat_end             LABEL     0088 136    .text
symbol_else_if          LABEL     0016 22     .text
while                   LABEL     0096 150    .text
while_end               LABEL     00A2 162    .text
ZERO                    ABSOLUTE  0000 0      .text
ZEROCHAR                ABSOLUTE  0030 48     .text

Code listing
   1           	; r0 = multiplicando
   2           	; r1 = multiplicador
   3           	
   4           	;1) a) Esta implementação ocupa 8 bytes de memória, devido ao uso de 4 registos(R0..R3), sendo cada um de 2 bytes tendo em conta as caracteristicas do processor P16.
   5           	;b) Enquanto grupo não concordamos com esta afirmação.
   6           	;Como sabemos os registos em rotinas encontram-se divididos em 3 classes,
   7           	;achamos que não seria preferivel a utilização do R4, pois ao contrário do R2,
   8           	 ;este registo tem necessidade de armazenar o seu valor, 
   9           	 ;tendo em conta o propósito da rotina multiply não faria sentido 
  10           	 ;guardar o valor sendo que o que nos importa é o valor final.
  11           	
  12           	;2) a) O valor da constante NAN é FFFF=65535, porque em hexadecimal cada valor 
  13           	;pode ser compreendido entre 0 e 15, onde 15=F. Neste caso o valor é positivo
  14           	;por ser do tipo uint16_t, ou seja, um intiero sem sinal de 16 bits.
  15           	
  16           	;b) .equ NAN, FFFF ocupa 16 bits, ou seja, 1 registo.
  17           	
  18           	;2 c)
  19           	
  20          	.equ NAN, 0xFFFF
  21          	.equ ZEROCHAR, '0'
  22          	.equ NINECHAR, '9'
  23          	.equ ACHAR, 'A'
  24          	.equ FCHAR, 'F'
  25          	.equ SIXTEEN, 16
  26           	
  27           	;r0 = symbol, r1 = radix, r2 = number
  28           	;r3 temporary values
  29           	
  30           	char2nat:
  31 0000 F2 6F	    mov r2, # NAN & 0xFF; number = NAN
  32 0002 F2 7F	    movt r2, # NAN & 0xFF
  33 0004 03 63	    mov r3, # ZEROCHAR
  34 0006 80 B9	    cmp r0, r3 
  35 0008 06 48	    blo symbol_else_if ; if(symbol < '0') -> symbol_else_if
  36 000A 93 63	    mov r3, # NINECHAR
  37 000C 30 B8	    cmp r3, r0
  38 000E 03 48	    blo symbol_else_if ; if(symbol > '9') -> symbol_else_if
  39 0010 03 63	    mov r3, # ZEROCHAR
  40 0012 82 89	    sub r2, r0, r3 ; number = symbol - '0'
  41 0014 09 58	    b radix_if1
  42           	
  43           	symbol_else_if:
  44 0016 13 64	    mov r3, # ACHAR
  45 0018 80 B9	    cmp r0, r3
  46 001A 06 48	    blo radix_if1    ; if(symbol < 'A') -> radix_if
  47 001C 63 64	    mov r3, # FCHAR
  48 001E 30 B8	    cmp r3, r0
  49 0020 03 48	    blo radix_if1    ; if( symbol > 'F') -> radix_if
  50 0022 13 64	    mov r3, # ACHAR
  51 0024 82 89	    sub r2, r0, r3 ; number = symbol - 'A'
  52 0026 22 A5	    add r2, r2, #10 ; number = number + 10
  53           	
  54           	radix_if1:
  55 0028 03 61	    mov r3, # SIXTEEN
  56 002A B0 B8	    cmp r3, r1
  57 002C 03 4C	    bhs radix_if2 ; if(radix <= 16) -> char2nat_end    
  58           	
  59           	number_nan:
  60 002E F2 6F	    mov r2, # NAN & 0xFF
  61 0030 F2 7F	    movt r2, # NAN & 0xFF
  62 0032 03 58	    b char2nat_end
  63           	
  64           	radix_if2:
  65 0034 A0 B8	    cmp r2, r1
  66 0036 01 48	    blo char2nat_end ; if(number < radix) -> char2nat_end
  67 0038 FA 5B	    b number_nan
  68           	
  69           	char2nat_end:
  70 003A 00 B1	    mov r0, r2
  71 003C 0F B7	    mov pc, lr
  72           	    
  73           	
  74           	;3)
  75           	
  76           	;r0 = &numeral[] , r1 = radix , r2 = number, r3 = error
  77           	;r4 = idx , r5 = tmp , r6/r7 temporario
  78          	.equ ZERO, 0
  79          	.equ ONE, 1
  80           	
  81           	str2nat:
  82 003E 04 24	    push r4 ; guardar os valores de r4, r5, r6 e r7 para nao serem perdidos
  83 0040 05 24	    push r5
  84 0042 06 24	    push r6
  85 0044 07 24	    push r7
  86 0046 02 60	    mov r2, # ZERO & 0xFF; number = 0
  87 0048 02 70	    movt r2, # ZERO & 0xFF
  88 004A 03 60	    mov r3, # ZERO ; error = 0
  89 004C 04 60	    mov r4, # ZERO ; idx = 0
  90           	
  91           	for_loop:
  92 004E 06 60	    mov r6, # ZERO
  93 0050 30 BB	    cmp r3, r6
  94 0052 1A 44	    bne str2nat_end ; if( error != 0 ) -> str2nat_end
  95 0054 06 60	    mov r6, # '\0'
  96 0056 07 12	    ldr r7, [r0,r4]
  97 0058 70 BB	    cmp r7, r6
  98 005A 16 40	    beq str2nat_end ; if( numeral[idx] == '\0' ) -> str2nat_end
  99 005C 07 B0	    mov r7, r0
 100 005E D0 5F	    bl char2nat
 101 0060 05 B0	    mov r5, r0 ; tmp = char2nat(numeral[idx], radix)
 102 0062 80 B3	    mov r0, r7
 103 0064 F6 6F	    mov r6, # NAN & 0xFF ; r6 = NAN
 104 0066 F6 7F	    movt r6, # NAN & 0xFF
 105 0068 50 BB	    cmp r5, r6 
 106 006A 04 44	    bne for_else
 107 006C F2 6F	    mov r2, # NAN & 0xFF
 108 006E F2 7F	    movt r2, # NAN & 0xFF
 109 0070 13 60	    mov r3, # ONE
 110 0072 ED 5B	    b for_loop
 111           	
 112           	for_else:
 113 0074 06 B0	    mov r6, r0
 114 0076 02 24	    push r2
 115 0078 03 24	    push r3
 116 007A 0C 5C	    bl multiply
 117 007C 03 04	    pop r3
 118 007E 02 04	    pop r2
 119 0080 07 B0	    mov r7, r0
 120 0082 00 B3	    mov r0, r6
 121 0084 F2 82	    add r2, r7, r5
 122 0086 E3 5B	    b for_loop
 123           	
 124           	str2nat_end:
 125 0088 07 04	    pop r7
 126 008A 06 04	    pop r6
 127 008C 05 04	    pop r5
 128 008E 04 04	    pop r4
 129 0090 00 B1	    mov r0, r2
 130 0092 0F B7	    mov pc, lr
 131           	
 132           	multiply: 
 133 0094 02 60	    mov r2, #0
 134           	while:
 135 0096 03 60	    mov r3, #0
 136 0098 B0 B8	    cmp r3, r1
 137 009A 03 4C	    bhs while_end
 138 009C 22 80	    add r2, r2, r0
 139 009E 91 A8	    sub r1, r1, #1
 140 00A0 FA 5B	    b while
 141           	while_end:
 142 00A2 00 B1	    mov r0, r2
 143 00A4 0F B7	    mov pc, lr
 144           	
 145           	; 4)
 146           	
 147           	; 5)
