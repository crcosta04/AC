P16 assembler v1.4.0 (Mar  6 2023)	trab01.lst	Wed Mar 22 12:49:09 2023

Sections
Index   Name            Address   Size
0       .startup        0000      0022 34
1       .text           0022      0106 262
2       .data           0128      0015 21
3       .bss            013E      0002 2
4       .stack          0140      0040 64

Symbols
Name                    Type      Value       Section
_start                  LABEL     0004 4      .startup
ACHAR                   ABSOLUTE  0041 65     .startup
char2nat                LABEL     007C 124    .text
char2nat_addr           LABEL     0076 118    .text
char2nat_end            LABEL     00B6 182    .text
EIGHT                   ABSOLUTE  0008 8      .startup
error                   LABEL     013E 318    .bss
error_addr              LABEL     007A 122    .text
error_addr2             LABEL     0126 294    .text
error_shift             LABEL     005C 92     .text
FCHAR                   ABSOLUTE  0046 70     .startup
for_else                LABEL     00F4 244    .text
for_loop                LABEL     00CA 202    .text
FOUR                    ABSOLUTE  0004 4      .startup
line#35                 LABEL     0002 2      .startup
line#50                 LABEL     001C 28     .startup
main                    LABEL     0022 34     .text
main_addr               LABEL     0020 32     .startup
multiply                LABEL     0114 276    .text
NAN                     ABSOLUTE  FFFF 65535  .startup
NINECHAR                ABSOLUTE  0039 57     .startup
number_nan              LABEL     00AA 170    .text
ONE                     ABSOLUTE  0001 1      .startup
radix_if1               LABEL     00A4 164    .text
radix_if2               LABEL     00B0 176    .text
shift                   LABEL     013F 319    .bss
shift_addr              LABEL     0074 116    .text
SIXTEEN                 ABSOLUTE  0010 16     .startup
STACK_SIZE              ABSOLUTE  0040 64     .startup
str2nat                 LABEL     00BA 186    .text
str2nat_addr            LABEL     0078 120    .text
str2nat_end             LABEL     0108 264    .text
symbol_else_if          LABEL     0092 146    .text
tos                     LABEL     0180 384    .stack
tos_addr                LABEL     001E 30     .startup
tst_results             LABEL     0128 296    .data
tst_results_addr        LABEL     0072 114    .text
tst_str0                LABEL     012E 302    .data
tst_str0_addr           LABEL     006C 108    .text
tst_str1                LABEL     0134 308    .data
tst_str1_addr           LABEL     006E 110    .text
tst_str2                LABEL     0138 312    .data
tst_str2_addr           LABEL     0070 112    .text
TWO                     ABSOLUTE  0002 2      .startup
while                   LABEL     0116 278    .text
while_end               LABEL     0122 290    .text
ZERO                    ABSOLUTE  0000 0      .startup
ZEROCHAR                ABSOLUTE  0030 48     .startup

Code listing
   1           	; r0 = multiplicando
   2           	; r1 = multiplicador
   3           	
   4           	;1) a) Esta implementação ocupa 8 bytes de memória, devido ao uso de 4 registos(R0..R3), sendo cada um de 2 bytes tendo em conta as caracteristicas do processor P16.
   5           	;b) Enquanto grupo não concordamos com esta afirmação.
   6           	;Como sabemos os registos em rotinas encontram-se divididos em 3 classes,
   7           	;achamos que não seria preferivel a utilização do R4, pois ao contrário do R2,
   8           	 ;este registo tem necessidade de armazenar o seu valor, 
   9           	 ;tendo em conta o propósito da rotina multiply não faria sentido 
  10           	 ;guardar o valor sendo que o que nos importa é o valor final.
  11           	
  12           	;2) a) O valor da constante NAN é FFFF=65535, porque em hexadecimal cada valor 
  13           	;pode ser compreendido entre 0 e 15, onde 15=F. Neste caso o valor é positivo
  14           	;por ser do tipo uint16_t, ou seja, um intiero sem sinal de 16 bits.
  15           	
  16           	;b) .equ NAN, FFFF ocupa 16 bits, ou seja, 1 registo.
  17           	
  18           	;2 c)
  19           	
  20          	.equ NAN, 0xFFFF
  21          	.equ ZEROCHAR, '0'
  22          	.equ NINECHAR, '9'
  23          	.equ ACHAR, 'A'
  24          	.equ FCHAR, 'F'
  25          	.equ SIXTEEN, 16
  26          	.equ STACK_SIZE, 64
  27          	.equ ZERO, 0
  28          	.equ ONE, 1
  29          	.equ TWO, 2
  30          	.equ FOUR, 4
  31          	.equ EIGHT, 8
  32           	
  33           	.section .startup
  34 0000 01 58	    b _start
  35 0002 FF 5B	    b .
  36           	
  37           	_start:
  38 0004 CD 0C	    ldr sp, tos_addr
  39 0006 00 60	    mov r0, # ZERO
  40 0008 11 60	    mov r1, # ONE
  41 000A 42 0F	    ldr r2, shift_addr
  42 000C 21 38	    strb r1, [r2, r0]
  43 000E 01 60	    mov r1, # ZERO
  44 0010 42 0F	    ldr r2, error_addr
  45 0012 21 38	    strb r1, [r2, r0]
  46 0014 80 B7	    mov r0, pc
  47 0016 0E A2	    add lr, r0, #4
  48 0018 3F 0C	    ldr pc, main_addr
  49 001A F2 0E	    ldr r2, error_addr
  50 001C FF 5B	    b .
  51           	
  52           	tos_addr:
  53 001E 80 01	    .word tos
  54           	
  55           	main_addr:
  56 0020 22 00	    .word main
  57           	
  58           	.text
  59           	
  60           	main:
  61 0022 0E 24	    push lr
  62 0024 30 0E	    ldr r0, tst_str0_addr
  63 0026 04 00	    ldr r4, [r0, # ZERO]
  64 0028 21 60	    mov r1, # TWO
  65 002A 47 5C	    bl str2nat
  66 002C 00 BA	    cmp r0, r4
  67 002E 86 B7	    mov r6, pc
  68 0030 65 A4	    add r5, r6, # EIGHT
  69 0032 05 24	    push r5
  70 0034 13 40	    beq error_shift
  71 0036 B0 0D	    ldr r0, tst_str1_addr
  72 0038 84 00	    ldr r4, [r0, # TWO]
  73 003A 81 60	    mov r1, # EIGHT
  74 003C 3E 5C	    bl str2nat
  75 003E 00 BA	    cmp r0, r4
  76 0040 86 B7	    mov r6, pc
  77 0042 65 A4	    add r5, r6, # EIGHT
  78 0044 05 24	    push r5
  79 0046 0A 40	    beq error_shift
  80 0048 30 0D	    ldr r0, tst_str2_addr
  81 004A 04 01	    ldr r4, [r0, # FOUR]
  82 004C 01 61	    mov r1, # SIXTEEN
  83 004E 35 5C	    bl str2nat
  84 0050 00 BA	    cmp r0, r4
  85 0052 86 B7	    mov r6, pc
  86 0054 65 A4	    add r5, r6, # EIGHT
  87 0056 05 24	    push r5
  88 0058 01 40	    beq error_shift
  89 005A 0F 04	    pop pc
  90           	
  91           	error_shift:
  92 005C 03 60	    mov r3, # ZERO
  93 005E D0 0C	    ldr r0, error_addr
  94 0060 81 C8	    orr r1, r0, r1
  95 0062 81 39	    strb r1, [r0, r3]
  96 0064 70 0C	    ldr r0, shift_addr
  97 0066 91 E0	    lsl r1, r1, # ONE
  98 0068 81 39	    strb r1, [r0, r3]
  99 006A 0F 04	    pop pc
 100           	
 101           	tst_str0_addr:
 102 006C 2E 01	    .word tst_str0
 103           	
 104           	tst_str1_addr:
 105 006E 34 01	    .word tst_str1
 106           	
 107           	tst_str2_addr:
 108 0070 38 01	    .word tst_str2
 109           	
 110           	tst_results_addr:
 111 0072 28 01	    .word tst_results
 112           	
 113           	
 114           	shift_addr:
 115 0074 3F 01	    .word shift
 116           	char2nat_addr:
 117 0076 7C 00	    .word char2nat
 118           	str2nat_addr:
 119 0078 BA 00	    .word str2nat
 120           	
 121           	error_addr:
 122 007A 3E 01	    .word error
 123           	
 124           	;r0 = symbol, r1 = radix, r2 = number
 125           	;r3 temporary values
 126           	
 127           	char2nat:
 128 007C F2 6F	    mov r2, # NAN & 0xFF; number = NAN
 129 007E F2 7F	    movt r2, # NAN & 0xFF
 130 0080 03 63	    mov r3, # ZEROCHAR
 131 0082 80 B9	    cmp r0, r3 
 132 0084 06 48	    blo symbol_else_if ; if(symbol < '0') -> symbol_else_if
 133 0086 93 63	    mov r3, # NINECHAR
 134 0088 30 B8	    cmp r3, r0
 135 008A 03 48	    blo symbol_else_if ; if(symbol > '9') -> symbol_else_if
 136 008C 03 63	    mov r3, # ZEROCHAR
 137 008E 82 89	    sub r2, r0, r3 ; number = symbol - '0'
 138 0090 09 58	    b radix_if1
 139           	
 140           	symbol_else_if:
 141 0092 13 64	    mov r3, # ACHAR
 142 0094 80 B9	    cmp r0, r3
 143 0096 06 48	    blo radix_if1    ; if(symbol < 'A') -> radix_if
 144 0098 63 64	    mov r3, # FCHAR
 145 009A 30 B8	    cmp r3, r0
 146 009C 03 48	    blo radix_if1    ; if( symbol > 'F') -> radix_if
 147 009E 13 64	    mov r3, # ACHAR
 148 00A0 82 89	    sub r2, r0, r3 ; number = symbol - 'A'
 149 00A2 22 A5	    add r2, r2, #10 ; number = number + 10
 150           	
 151           	radix_if1:
 152 00A4 03 61	    mov r3, # SIXTEEN
 153 00A6 B0 B8	    cmp r3, r1
 154 00A8 03 4C	    bhs radix_if2 ; if(radix <= 16) -> char2nat_end    
 155           	
 156           	number_nan:
 157 00AA F2 6F	    mov r2, # NAN & 0xFF
 158 00AC F2 7F	    movt r2, # NAN & 0xFF
 159 00AE 03 58	    b char2nat_end
 160           	
 161           	radix_if2:
 162 00B0 A0 B8	    cmp r2, r1
 163 00B2 01 48	    blo char2nat_end ; if(number < radix) -> char2nat_end
 164 00B4 FA 5B	    b number_nan
 165           	
 166           	char2nat_end:
 167 00B6 00 B1	    mov r0, r2
 168 00B8 0F B7	    mov pc, lr
 169           	
 170           	;3)
 171           	
 172           	;r0 = &numeral[] , r1 = radix , r2 = number, r3 = error
 173           	;r4 = idx , r5 = tmp , r6/r7 temporario
 174           	
 175           	str2nat:
 176 00BA 04 24	    push r4 ; guardar os valores de r4, r5, r6 e r7 para nao serem perdidos
 177 00BC 05 24	    push r5
 178 00BE 06 24	    push r6
 179 00C0 07 24	    push r7
 180 00C2 02 60	    mov r2, # ZERO & 0xFF; number = 0
 181 00C4 02 70	    movt r2, # ZERO & 0xFF
 182 00C6 F3 0E	    ldr r3, error_addr2; error = 0
 183 00C8 04 60	    mov r4, # ZERO ; idx = 0
 184           	
 185           	for_loop:
 186 00CA 06 60	    mov r6, # ZERO
 187 00CC 30 BB	    cmp r3, r6
 188 00CE 1C 40	    beq str2nat_end ; if( error != 0 ) -> str2nat_end
 189 00D0 06 60	    mov r6, # '\0'
 190 00D2 07 12	    ldr r7, [r0,r4]
 191 00D4 70 BB	    cmp r7, r6
 192 00D6 18 44	    bne str2nat_end ; if( numeral[idx] == '\0' ) -> str2nat_end
 193 00D8 07 B0	    mov r7, r0
 194 00DA D0 5F	    bl char2nat
 195 00DC 05 B0	    mov r5, r0 ; tmp = char2nat(numeral[idx], radix)
 196 00DE 80 B3	    mov r0, r7
 197 00E0 F6 6F	    mov r6, # NAN & 0xFF ; r6 = NAN
 198 00E2 F6 7F	    movt r6, # NAN & 0xFF
 199 00E4 50 BB	    cmp r5, r6 
 200 00E6 06 44	    bne for_else
 201 00E8 F2 6F	    mov r2, # NAN & 0xFF
 202 00EA F2 7F	    movt r2, # NAN & 0xFF
 203 00EC 14 60	    mov r4, # ONE
 204 00EE 07 60	    mov r7, # ZERO
 205 00F0 B4 33	    str r4, [r3, r7]
 206 00F2 EB 5B	    b for_loop
 207           	
 208           	for_else:
 209 00F4 06 B0	    mov r6, r0
 210 00F6 02 24	    push r2
 211 00F8 03 24	    push r3
 212 00FA 0C 5C	    bl multiply
 213 00FC 03 04	    pop r3
 214 00FE 02 04	    pop r2
 215 0100 07 B0	    mov r7, r0
 216 0102 00 B3	    mov r0, r6
 217 0104 F2 82	    add r2, r7, r5
 218 0106 E1 5B	    b for_loop
 219           	
 220           	str2nat_end:
 221 0108 07 04	    pop r7
 222 010A 06 04	    pop r6
 223 010C 05 04	    pop r5
 224 010E 04 04	    pop r4
 225 0110 00 B1	    mov r0, r2
 226 0112 0F B7	    mov pc, lr
 227           	
 228           	multiply: 
 229 0114 02 60	    mov r2, #0
 230           	while:
 231 0116 03 60	    mov r3, #0
 232 0118 B0 B8	    cmp r3, r1
 233 011A 03 4C	    bhs while_end
 234 011C 22 80	    add r2, r2, r0
 235 011E 91 A8	    sub r1, r1, #1
 236 0120 FA 5B	    b while
 237           	while_end:
 238 0122 00 B1	    mov r0, r2
 239 0124 0F B7	    mov pc, lr
 240           	
 241           	error_addr2:
 242 0126 3E 01	    .word error
 243           	
 244           	; 4)
 245           	
 246           	.data
 247           	
 248           	tst_results:
 249          	    .word 11, 457, 39439
 249 0128 0B 00 C9 01 0F 9A
 250           	
 251           	tst_str0:
 252          	    .asciz "01011"
 252 012E 30 31 30 31 31 00
 253           	
 254           	tst_str1:
 255          	    .asciz "709"
 255 0134 37 30 39 00
 256           	
 257           	tst_str2:
 258          	    .asciz "9A0F"
 258 0138 39 41 30 46 00
 259           	
 260           	.section .bss
 261           	
 262           	error:
 263 013E 00   	    .space 1
 264           	
 265           	shift:
 266 013F 00   	    .space 1
 267           	
 268           	.section .stack
 269 0140 00   	    .space STACK_SIZE
 269 .... ..
 269 017F 00
 270           	tos:
 271           	; 5)
